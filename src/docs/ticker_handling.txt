ticker handling 
===============


Case 1: Request market data snapshot
------------------------------------

1. (client) Symbol <-> 2. (client messaging) Contract-key <-> 3. (server messaging) Contract-key <-> 4. (tws) ticker_id


1. Create symbol
- contract = ContractTuple(....)
- symbol = Symbol(contract) 

2. Request market data
- object:contract-key
- reqMktData(ContractHelper(symbol.getContract(), snapshot=True)
- encode message object for kafka transport {'contract':contract, 'snapshot':snapshot}
- TWS_client_manager(GatewayCommandWrapper) -> reqMktData(encoded message object)
- GatewayCommandWrapper -> producer.send_message('reqMktData', json_message_str)

3. Process request
- prosumer/ BaseConsumer baseconsumer: self.dispatch(message.topic, **self.extract_message_content(message))
- ClientRequestHandler(BaseMessageListener) -> reqMktData -> subscription_mgr.reqMktData(contract_object, snapshot)

4. map id:key 
- tws_connection -> reqMktData(id + 1000|id, contract, True|False)

Case 2: Receive market data from TWS

5. tws <-> 6. server messaging <-> 7. client messaging <-> 8. client

5. Receive tickPrice 
- comms.ibgw.tws_event_handler TWS_event_handler(EWrapper) -> tickPrice -> remap id:contract-key
- update vars() by replacing tickId with contract-key subscrition_manager.get_contract_by_id
6
- tws_event_handler->self.broadcast_event('tickPrice', {self.subscription_manger.get_contract_by_id(tickerId),
                                           field, price, canAutoExecute})
- self.producer.send_message(message, self.producer.message_dumps(dict))


7
-  
- baseconsumer: self.dispatch(message.topic, **self.extract_message_content(message))
- Inherit AbstractGatewayListener(BaseMessageListener) / tickPrice(tickerId, field, price, canAutoExecute):


     




